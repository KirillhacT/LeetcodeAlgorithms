f(n) = O(g(n)) - высшая граница работы алгоритма
сущ n0,c где при каждом n >= n0: f(n) <= c * g(n)

ex:
    (3 + 5n === f(n)), (n === g)
    T(n) = 3 + 5n (пример c доски)
    n0 = 4; c = 6 (числа из головы)
    3 + 5n <= 6 * n при n >= 4
    3 <= n при n >= 4

    n = O(n^2); n0 = 1 c = 1
    n <= n^2 при n >= 1
    1 <= n при n >= 1

    f(n) = Omega(g(n)) - низшая граница работы алгоритма
    ... but
    сущ n0,c где при каждом n >= n0: f(n) >= c * g(n)

    Докажем 3 + 5n = Omega(n)
    n0 = 1; c = 1
    3 + 5n = n при n >= 1

    T(n) = O(n), T(n) = Omega(n) =>
    T(n) = 0(n) [Delta]


for i=0..n-1:
    for j=0..n-1:  --> O(n^2)
        ...


for i=0..n-1:
    for j=0..i-1:  --> O(n^2)
        ...


i = 1
while i * i < n:   --> O(n^0.5)
    i++


i = 1
while i < n:     --> O(logn)
    i = i * 2


f(n):
    if n == 0:
        ...   --> O(n)
    f(n - 1) 
f(n) -> f(n - 1) -> f(n - 2) -> ... -> f(0) [n раз]


f(n):
    if n == 0:
        ...   --> O(logn)
    f(n / 2) 
f(n) -> f(n / 2) -> f(n / 4) -> ... -> f(0) [logn раз]

f(n):
    if n == 0:
        ...   --> O(logn)
    f(n / 2) 
    f(n / 2)
всего 2^h, где h - уровень каждого
h (в данном случае) = logn
2^log2n = n 

если будет 3 вызова рекурсивной функции
то асимптотика будет 3^h и т.д

Сортировка вставками
for i=0...n-1:
    j=i
    while j>0 and a[j] < a[j-1]:
        swap(a[j], a[j - 1])
        j--
Cортировка слиянием
merge:
    ...

sort(a):
    if a.size() == 1:
        return a
    al = a[0..n/2-1]
    ar = a[n/2..n-1]
    sort(al) [T(n/2)]
    sort(ar) [T(n/2)]
    return merge(al, ar)
мы делаем два вызова O(logn) каждый (так как массив делится на 2)
так получаем асимптотику O(2^logn) = O(n)

T(n) = 2T(n/2) + n




