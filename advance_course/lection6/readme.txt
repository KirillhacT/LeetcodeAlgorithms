Амортизированный анализ
O1.O2.03...0k

T(Oi) - время работы опер.
T'(Oi) - амортизированное время опер.

Амортизированное время работы алгоритма хорошее, если:
если SUM(T'(Oi)) >= SUM(T(Oi))

push,push,push... -> суммарно k операций
2^p <= 3k
SUM(T) <= k + 2^p
T'push = 3

был массив [...] -> [......] -> [............] -> [........................] (2^p)


F - потенциал
delt<(F)> -> разность потенциалов (Fк - Fн)
T' = T + delt<(F)>
F0 = 0, F >= 0
SUM(T') = SUM(T) + SUM(delt<(F)>)

(. - заполнено; , - не заполнено)
[..........]  [F = n]
[..........|,,,,,,,,,,] [F = 0]
F = (число в правой половине массива) * 2
T' = 1 + 1 = O(1)
n + (-n) + 1 = O(1)

3 способ анализа
Бух. учет (Монетки)
put_coin(x) //T' = x
take_coin(x) //T' = -x

push()
 2222 -> n
[....] (при добавлении элемента запасаем по 2 монетки, которые распределяем, чтобы
расширить массив)
[....,,,,]
       n
pop()
[...11,,,,]
     n
n <= a.size() / 4 (При удалении элемента запасаем одну монетку, чтобы за их счет
сузить массив)
[...,,]


Амортизированное время использует накопленное предыдущее
Мы виртуально перераспределяем время
У нас есть структура данных и у нее было много простых (.) и немного сложных
операций (------|)
T ........------|
T' -.-.-.-.-.-.-. (мы хотим найти среднее время по всем операциям)

Делаем очередь из двух стеков
s1 [.........] <- ->
s2 [.........] <- -> 
<- [........|.........] <-
add(x):
    s2.push(x)
remove():
    if s1.empty():
        while not s2.empty():
            s1.push(s2.pop())
    return s1.pop()
        3 coins
[......|ABC....] (s1.push(s2.pop()), s1.push(s2.pop()), s1.push(s2.pop()))
[...ABC|.......]
s1.pop() -> достаем элемент из нашей очереди


[....X....-X] сумма на отрезке одинаковая





