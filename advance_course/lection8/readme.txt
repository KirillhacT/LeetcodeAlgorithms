Система Непересекающихся множеств (Union find)
union(x, y) //Объединяет множества с эл x, y
get(x) -> возвращает множество, в котором лежит x
пусть в каждом множестве будет свой представитель 
(идентефикатор) обозн .
          .       .       .       .
system = {1, 3}, {7}, {2, 5}, {4, 6, 8}
get(2) = 5
get(4) = 6

index в нашем случае это элемент system
p[index] -> представитель множества 
     1  2  3  4  5  6  7  8
p = [1, 5, 1, 6, 5, 6, 7, 6]
get(x): (возвращает представителя множества, к которому
относится x)
    return p[x]
union(x, y):
    x = p[x], y = p[y]
    pr = max(x, y) //Выбираем лучшего представителя
    for i = 1..p.size()-1:
        if p[i] == x:
            p[i] = y
оптимизация, для каждого x заведем массив
list = [
    1: 1, 3
    2: 
    3
    4 
    5: 2, 5
    6: 4, 8, 6
    7: 7
    8
]
union(x, y):
    x = get(x), y = get(y)
    if list[x].size() > list[y].size():
        x, y = y, x
    pr = max(x, y) //Выбираем лучшего представителя
    
    
    for i = 1..list[x].size():
        p[i] = y
        list[y].append(i)
    del list[x]

Если мы склеиваем структуры данных, то наилучшим решением
будет сливать все элементы из большей структуры в меньшую
(за logn)

Множества как деревья (представитель это корень дерева)
4 <- 1 <- 3
2 <- 6

1. p[x] - родитель x в дереве
get(x):
    while p[x] != x:
        x = p[x]
    return x
union(x, y):
    x = get(x), y = get(y)
    p[x] = y

Cжатие путей: мы рекурсивно выставляем след узел на root
def get(cls, x):
    if x.next == None:
        return x
    root = get(x.next)
    x.next = root
    return root

lg*n -> показывает сколько нужно взять логарифм от n
lg*2^65536 = 6
lg*2^16 = 5
lg*2^4 = 4
lg*2^2 = 3
lg*2^1 = 2
1 = 1
0 = 0


