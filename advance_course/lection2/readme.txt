Структуры данных

Двоичная куча:
    Куча хранит множество элементов
    У них есть особый порядок
    insert(x)  // A = A or {x}
    remove_min() 

    Реализации кучи
    (1) Массив
           0       n-1
    a  =   [....j....|,,,,]
    insert(x):          --> O(1)
        a[n++] = x  
    remove_min():       --> O(n) 
        j = 0
        for i = 1 ... n - 1
            if a[i] < a[j]
                j = i    
        swap(a[j], a[n-1])
        return a[--n]
    
    (2) Отсортируем Массив по убыванию (a[0] -> max, a[n-1] -> minimum)
           0       n-1
    a  =   [.........|,,,,] 
    remove_min():       --> O(1)
        return a[--n]
    insert(x):          --> O(n) 
        a[n++] = x
        i = n - 1
        while i > 0 and a[i - 1] < a[i]:
            swap(a[i], a[i - 1])
            i-- 

    (3) Бинарная куча (храним в массиве)
    Рассмотрим бинарное дерево (стр. 1 в тетр.)
    Свойство кучи: у родителя всегда элемент меньше или равен дочернему
    минимум (или максимум) находится в корне
    ссылка на детей узла c индексом i: 2i + 1 и 2i + 2 cоответственно
    ссылка на родителя узла с индексом i: (i - 1) // 2 

           0                                    n-1
    a  =   [3, 7, 5, 8, 11, 10, 13, 14, 27, 18, 38]

           0                                    n-1
    a  =   [3, 7, 5, 8, 11, 10, 13, 14, 27, 18, 38 | 4]


    insert(x)   --> O(logN)
        a[n++] = x
        i = n - 1
        while i > 0 and a[i] < a[(i-1)/2]   # a[(i-1)//2] - родидеть узла if
            swap(a[i], a[(i-1)/2])
            i = (i-1)//2

    меняем последний элемент и самый первый, и удаляем последний 
    remove_min() --> O(logN)
        res = a[0]
        a[0] = a[--n]
        i = 0
        while True:
            j = i
            if 2i + 1 < n and a[2i + 1] < a[j]
                j = 2i + 1
            if 2i + 2 < n and a[2i + 2] < a[j]
                j = 2i + 2
            if j == i: break
            swap(a[i], a[j])
            i = j 
        return res

    Сортировка кучей
    (1) В первом цикле добавляем все элементы из массива в кучу методом insert
    (2) Во втором цикле в массив вытаскиваем минимальный из кучи

    Сортировка кучей Implace
    (1) Превращаем наш массив в большую кучу первым циклом просеивая каждый элемент
    наверх (ну или наоборот в обратном порядке просеивая вниз)
    (2) Меняем первый элемент кучи и последний местами и далее просеиваем 
    самый первый вниз (первый элемент гарантировано встанет назад, тоесть отсортируется)
    И так делаем с каждым элементом
    



     











